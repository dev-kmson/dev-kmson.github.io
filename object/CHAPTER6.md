---
sort: 6
---

# 메시지와 인터페이스

> ***애플리케이션은 클래스를 통해 구성되지만 메시지를 통해 정의된다는 사실을 기억하라***

훌륭한 객체지향 코드를 얻기 위해서는 클래스가 아니라 객체를 지향해야 한다.  
좀 더 정확하게 말해서 협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다.  
여기서 중요한 것은 **책임이 객체가 수신할 수 있는 메시지의 기반**이 된다는 것이다.  

디미터 법칙은 객체 간의 협력을 설계할 때 캡슐화를 위반하는 메시지가 인터페이스에 포함되지 않도록 제한한다.  
묻지 말고 시켜라 원칙은 디미터 법칙을 준수하는 협력을 만들기 위한 스타일을 제시한다.  
의도를 드러내는 인터페이스 원칙은 객체의 퍼블릭 인터페이스에 어떤 이름이 드러나야 하는지에 대한 지침을 제공함으로써  
코드의 목적을 명확하게 커뮤니케이션할 수 있게 해준다.  

우리는 결합도가 낮으면서도 의도를 명확히 드러내는 간결한 협력을 원한다.  
디미터 법칙과 묻지 말고 시켜라 스타일, 의도를 드러내는 인터페이스가 우리를 도울 것이다.

---

> ***메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단이다***

메시지는 오퍼레이션명(Operation Name)과 인자(Argument)로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.  
따라서 **메시지 전송은 메시지 수신자, 오퍼레이션명, 인자의 조합**이다.  

메시지를 수신했을 때 실제로 어떤 코드가 실행되는지는 메시지 수신자의 실제 타입이 무엇인가에 달려 있다.  
메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.  
중요한 것은 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실행되는 메서드가 달라질 수 있다는 것이다.  
객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 **실행 시점에 연결**해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.  

중요한 것은 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정한다는 것이다.  
객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.

> ***낯선 자에게 말하지 말라***

협력하는 객체의 내부 구조에 대한 결합으로 인해 발생하는 설계 문제를 해결하기 위해 제안된 원칙이 바로 디미터 법칙(Law of Demeter)이다.  
디미터 법칙은 간단하게 요약하면 **객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것**이다.  
"낯선 자에게 말하지 말라" 또는 "오직 인접한 이웃하고만 말하라"로 요약할 수 있다.  
도트(.)를 이용해 메시지 전송을 표현하는 언어에서는 "오직 하나의 도트만 사용하라"라는 말로 요약되기도 한다.  

디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다.  
캡슐화 원칙이 클래스 내부의 구현을 감춰야 한다는 사실을 강조한다면  
디미터 법칙은 **협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한**한다.  

메시지 전송자가 수신자의 내부 구조에 대해 물어보고 반환받은 요소에 대해 연쇄적으로 메시지를 전송하는  
**기차 충돌(train wreck)의 형태를 띄는 코드는 클래스의 내부 구현이 외부로 노출됐을 때 나타나는 전형적인 형태**로  
메시지 전송자는 메시지 수신자의 정보를 자세히 알게 된다.  
따라서 메시지 수신자의 캡슐화는 무너지고, 메시지 전송자가 메시지 수신자의 내부 구현에 강하게 결합된다.  

> ***묻지 말고 시켜라***

메시지 전송자는 **메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안 된다**.  
객체의 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를 위반한다.  

묻지 말고 시켜라 원칙을 따르면 밀접하게 연관된 정보와 행동을 함께 가지는 객체를 만들 수 있다.  
객체지향의 기본은 함께 변경될 확률이 높은 정보와 행동을 하나의 단위로 통합하는 것이다.  
묻지 말고 시켜라 원칙을 따르면 객체의 정보를 이용하는 행동을 객체의 외부가 아닌 내부에 위치시키기 때문에  
자연스럽게 정보와 행동을 클래스 안에 두게 된다.  
묻지 말고 시켜라 원칙에 따르도록 메시지를 결정하다보면 자연스럽게 정보 전문가에게 책임을 할당하게 되고  
높은 응집도를 가진 클래스를 얻을 확률이 높아진다.

> ***'어떻게'가 아니라 '무엇'을 하는지를 드러내라***

메서드가 어떻게 수행하는지를 드러내는 이름이란 메서드의 내부 구현을 설명하는 이름이다.  
결과적으로 협력을 설계하기 시작하는 이른 시기부터 **클래스의 내부 구현에 관해 고민**할 수 밖에 없다.  
반면 무엇을 하는지를 드러내도록 메서드의 이름을 짓기 위해서는 **객체가 협력 안에서 수행해야 하는 책임에 관해 고민**해야 한다.  
이것은 외부의 객체가 메시지를 전송하는 목적을 먼저 생각하도록 만들며,  
결과적으로 **협력하는 클라이언트의 의도에 부합하도록 메서드의 이름을 짓게 된다**.  
메서드가 어떻게 수행하느냐가 아니라 무엇을 하느냐에 초점을 맞추면 클라이언트의 관점에서  
동일한 작업을 수행하는 메서드들을 하나의 타입 계층으로 묶을 수 있는 가능성이 커진다.  
그 결과, 다양한 타입의 객체가 참여할 수 있는 유연한 협력을 얻게 되는 것이다.  
이처럼 어떻게 하느냐가 아니라 무엇을 하느냐에 따라 메서드의 이름을 짓는 패턴을  
**의도를 드러내는 선택자(Intention Revealing Selector)** 라고 부른다.  

의도를 드러내는 선택자를 인터페이스 레벨로 확장한 **의도를 드러내는 인터페이스(Intention Revealing Interface)** 는  
구현과 관련된 모든 정보를 캡슐화하고 객체의 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 함을 말한다.

> ***질문이 답변을 수정해서는 안 된다***

**명령-쿼리 분리(Command-Query Separation) 원칙**은 퍼블릭 인터페이스에 오퍼레이션을 정의할 때 참고할 수 있는 지침을 제공한다.  
**명령은 상태를 변경할 수 있지만 상태를 반환해서는 안 된다**.  
**쿼리는 객체의 상태를 반환할 수 있지만 상태를 변경해서는 안 된다**.  

명령과 쿼리는 객체의 인터페이스 측면에서 프로시저와 함수를 부르는 또 다른 이름이다.  
객체의 상태를 수정하는 오퍼레이션을 명령 또는 프로시저라고 부르고  
객체와 관련된 정보를 반환하는 오퍼레이션을 쿼리 또는 함수라고 부른다.  

명령-쿼리 분리 원칙의 요지는 오퍼레이션은 부수효과를 발생시키는 명령이거나  
부수효과를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.  
어떤 오퍼레이션도 명령인 동시에 쿼리여서는 안 된다.  

명령과 쿼리를 뒤섞으면 실행 결과를 예측하기가 어려워질 수 있다.  
쿼리처럼 보이지만 내부적으로 부수효과를 가지는 메서드는 이해하기 어렵고,  
잘못 사용하기 쉬우며, 버그를 양산하는 경향이 있다.  
가장 깔끔한 해결책은 명령과 쿼리를 명확하게 분리하는 것이다.  
그 결과, 코드는 예측 가능하고 이해하기 쉬우며 디버깅이 용이한 도잇에 유지보수가 수월해질 것이다.

---

- 메시지
    - 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘  
    - 일반적으로 객체의 오퍼레이션이 실행되도록 요청하는 것을 '메시지 전송'이라고 부름  
    - 메시지는 협력에 참여하는 전송자와 수신자 양쪽 모두를 포함하는 개념
    
    
- 오퍼레이션
    - 객체가 다른 객체에게 제공하는 추상적인 서비스
    - 메시지가 전송자와 수신자 사이의 협력 관계를 강조하는 데 비해 오퍼레이션은 **메시지를 수신하는 객체의 인터페이스를 강조**
    - 메시지 전송자는 고려하지 않은 채 메시지 수신자의 관점만을 다룸
    - **메시지 수신이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것**을 의미
    

- 메서드
    - 메시지를 응답하기 위해 실행되는 코드 블록
    - 메서드는 **오퍼레이션의 구현**
    - 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있음
    - **오퍼레이션과 메서드의 구분은 다형성의 개념과 연결**
    

- 퍼블릭 인터페이스
    - 객체가 협력에 참여하기 위해 **외부에서 수신할 수 있는 메시지의 묶음**
    - 클래스의 퍼블릭 메서드들의 집합이나 메시지의 집합을 가리키는 데 사용
    - 객체를 설계할 때 가장 중요한 것은 훌륭한 퍼블릭 인터페이스를 설계하는 것
    

- 시그니처
    - **오퍼레이션이나 메서드의 명세**를 나타낸 것
    - 이름과 인자의 목록을 포함
    

*메시지를 제외하고는 모두 수신자의 관점에서 용어를 해석하는 것이 이해하기 수월해 보임.  
메시지 전송 시 대응되는 것 : 오퍼레이션  
오퍼레이션의 구현 : 메서드   
오퍼레이션의 명세 : 시그니처  
오퍼레이션의 집합 : 퍼블릭 인터페이스 (협력적 관점에서 보면 메시지의 집합)*


- 디미터 법칙
  - 객체 내부 구조에 강하게 결합되지 않도록 **협력 경로를 제한**하는 것
  - 객체는 내부 구조를 숨겨야 하므로 디미터 법칙을 따르는 것이 좋지만  
    자료구조는 당연히 내부를 노출해야 하므로 디미터 법칙을 적용할 필요가 없음
  - 다음을 만족하는 경우에만 메시지를 전송하도록 함  
    - **객체 자신**
    - **메서드의 매개변수로 넘어온 인자**
    - **인스턴스 변수로 가지고 있는 객체**
    - **메서드 내에서 생성된 객체**


- 명령-쿼리 분리 원칙
  - 객체의 상태를 변경하는 명령은 반환값을 가질 수 없음
  - 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없음





