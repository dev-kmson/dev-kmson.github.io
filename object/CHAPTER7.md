---
sort: 7
---

# 객체 분해

---

## 추상화 메커니즘

    - 프로시저 추상화와 데이터 추상화 두 가지 메커니즘 존재
    - 프로시저 추상화(procedure abstraction): 기능 분해를 의미, 알고리즘 분해라고도 불림
    - 데이터 추상화(data abstraction): 추상 데이터 타입과 객체지향으로 나뉨
        - 추상 데이터 타입(Abstract Data Type): 데이터를 중심으로 타입을 추상화
        - 객체지향(Object-Oriented): 데이터를 중심으로 프로시저를 추상화

## 프로시저 추상화

    - 오랜 시간 동안 시스템을 분해하기 위한 기준으로 사용
    - 기능 분해의 관점에서 추상화의 단위는 프로시저

### 하향식 접근법

    - Top-Down Approach
    - 최상위의 가장 추상적인 메인 함수를 정의하고 세부적인 단계로 분해하는 방법
    - 작은 프로그램 혹은 개별 알고리즘을 위해서는 유용한 패러다임
    - 이미 해결된 알고리즘을 문서화하고 서술하는 데는 훌륭한 기법

#### 하향식 접근법의 문제점

    - 시스템은 하나의 메인 함수로 구성되어 있지 않음
    - 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정
    - 비즈니스 로직이 사용자 인터페이스와 강하게 결합
    - 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하
        - 시간 제약(temporal constraint), 중앙집중 제어 스타일(centralized control style)
        - 하위 함수는 상위 함수가 강요하는 문맥 안에서만 의미를 가짐, 문맥에 강하게 결합 
    - 데이터 형식이 변경될 경우 파급효과를 예측할 수 없음

## 정보 은닉과 모듈

    - 기능 분해가 가진 본질적인 문제를 해결하기 위해 정보 은닉과 모듈이라는 개념이 제시
    - 정보 은닉은 외부에 감춰야 하는 비밀에 따라 시스템을 분할하는 모듈 분할의 원리
    - 모듈과 기능 분해는 상호배타적인 관계가 아님
        - 시스템을 모듈로 분해한 후에는 각 모듈 내부를 구현하기 위해 기능 분해를 적용

### 모듈의 장점

    - 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향
    - 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리
    - 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지

### 모듈의 단점

    - 모듈이 프로시저 추상화보다는 높은 추상화 개념을 제공하지만 추상화 관점에서 한계점이 명확
    - 모듈의 가장 큰 단점은 인스턴스의 개념을 제공하지 않는다는 점        

## 데이터 추상화

### 추상 데이터 타입

    - 인스턴스 개념의 필요로 인하여 등장하게 됨
    - 인스턴스 개념이 적용된 추상 데이터 타입을 구현하기 위해 프로그래밍 언어의 지원이 필요
        - 타입 정의를 선언할 수 있어야 함
        - 타입의 인스턴스를 다루기 위해 사용할 수 있는 오퍼레이션의 집합을 정의할 수 있어야 함
        - 제공된 오퍼레이션을 통해서만 조작할 수 있도록 데이터를 외부로부터 보호할 수 있어야 함
        - 타입에 대해 여러 개의 인스턴스를 생성할 수 있어야 함
    - 객체기반 프로그래밍(Object-Based Programming): 추상 데이터 타입 기반의 프로그래밍 패러다임
    - 타입 추상화를 기반으로 하는 대표적인 기법
        - 타입 추상화는 모든 개념적인 타입에 대한 구현을 포괄하도록 함으로써 하나의 물리적인 타입 안에 전체 타입을 감춤

#### 추상 데이터 타입의 문제점

    - 추상 데이터 타입 정의를 기반으로 객체 생성은 가능하지만 여전히 데이터와 기능을 분리해서 바라봄
    - 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재
    - 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀있음

## 객체지향

    - 객체지향은 절차 추상화(procedural abstraction)
    - 추상 데이터 타입과 클래스는 동일하지 않음
    - 클래스는 상속과 다형성을 지원, 추상 데이터 타입은 지원하지 못함 

### 추상 데이터 타입과의 차이점

    - 추상 데이터 타입은 오퍼레이션을 기준으로 타입을 묶는 방법
        - 특정 오퍼레이션의 구현이 조건문을 통해 타입 별로 처리함
    - 객체지향은 타입을 기준으로 오퍼레이션을 묶는 방법
        - 여러 타입을 클래스로 분리한 후 다형성을 이용해 절차에 대한 차이점을 감춤
    - 추상 데이터 타입 : 데이터 주도 설계, 데이터 중심적인 관점 
    - 객체지향 : 책임 주도 설계, 서비스 중심적인 관점
    
## 변경의 방향성

    - 타입 추가에 대한 변경의 압력이 더 강한 경우에는 객체지향 설계
    - 오퍼레이션 추가에 대한 변경의 압력이 더 강한 경우에는 추상 데이터 타입 설계 
    - 객체지향적인 접근법이 모든 경우에 올바른 해결 방법인 것은 아님

***<span style="color:#f08080">
오퍼레이션 안에 여러 타입 혹은 상황에 따라 조건문으로 분기 처리되고 있다면 객체지향적 설계가 아니다  
여러 클래스로 분리하고 다형성을 이용하여 인터페이스 뒤에 캡슐화로 내부 구현을 감추자
</span>***







