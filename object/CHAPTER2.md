---
sort: 2
---

## 객체지향 프로그래밍

>*어떤 클래스가 필요한지를 고민하기 전에 **어떤 객체들이 필요한지 고민**하라*  

진정한 객체지향 패러다임으로의 전환은 **클래스가 아닌 객체에 초점**을 맞출때에만 얻을 수 있다.  
클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 어떤 행동을 가지는지를 먼저 결정해야 한다.  

---

- ## 도메인(Domain)
    - 소프트웨어로 해결하고자하는 문제 영역, 대상
    - 클래스의 이름은 대응되는 도메인 개념의 이름과 **동일하거나 적어도 유사하게** 지어야 한다.
    - 클래스의 구조는 도메인의 구조와 **유사한 형태**를 띠어야 한다.
  
- ## 구현 은닉(Implementation Hiding)
    - 클래스 작성자는 클라이언트 프로그래머에게 **필요한 부분만 공개**할 수 있어야 하고,  
      클라이언트 프로그래머가 공개되지 않은 부분에 마음대로 **접근할 수 없도록 방지**되어야만  
      클라이언트 프로그래머로 인한 영향을 걱정하지 않고도 **내부 구현을 마음대로 변경**할 수 있다.

- ## 인터페이스와 구현의 분리(Separation of Interface and Implementaiton)
    - 캡슐화와 접근제어는 객체를 외부에서 접근 가능한 **퍼블릭 인터페이스**(Public Interface)와  
      오직 내부에서만 접근 가능한 **구현**(Implementation)으로 나눈다.
    - 인터페이스와 구현의 분리는 훌륭한 객체지향 프로그램을 만들기 위해 따라야 하는 핵심 원칙이다.

- ## 차이에 의한 프로그래밍(Programming by Difference)
    - 슈퍼클래스와 다른 부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법
    - 상속은 기존 클래스를 기반으로 새로운 클래스를 쉽고 빠르게 추가할 수 있는 간편한 방법을 제공한다.
    
---
> *객체가 다른 객체와 상호작용할 수 있는 **유일한 방법은 메시지를 전송하는 것** 뿐이다  
> 메시지를 수신한 객체는 **스스로의 결정에 따라 자율적으로 메시지를 처리할 방법을 결정**한다    
> 메시지를 처리하기 위한 **자신만의 방법을 메서드**라고 부른다*
>> *메시지와 메서드의 구분에서부터 **다형성(Polymorphism)의 개념이 출발**한다*  

> *설계가 필요한 이유는 **변경을 관리**하기 위함이다*

> *컴파일 시점의 의존성과 런타임 시점의 의존성이 서로 다를 수 있다  
> 컴파일 시점의 의존성과 런타임 시점의 의존성이 다르면 다를수록 객체를 생성하고  
> 연결하는 부분을 찾아야 하기 때문에 코드를 이해하기 더욱 어려워지는 반면,  
> 코드는 **더욱 유연해지고 확장 가능**해진다*  
>> *이와 같이 의존성의 양면성은 설계가 **트레이드오프의 산물이라는 사실의 반증**이다  
> 유연성과 가독성 사이에서 고민해야한다  
> 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답이 아니다*

> *메시지와 메서드는 다른 개념이다  
> 동일한 메시지를 전송하더라도 실제로 어떤 메서드가 실행될 것인지는  
> 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다*
>> *다형성은 **객체지향 프로그램의 컴파일 시간 의존성과 런타임 시간 의존성이 다를 수 있다는 사실을 기반**으로 한다  
> 다형성이란 동일한 메시지를 수신했을 때 **객체의 타입에 따라 다르게 응답할 수 있는 능력**을 의미한다  
> 따라서, 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다  
> 즉, **인터페이스가 동일**해야 함을 의미한다*
>>> *협력에 참여하는 객체들이 모두 같은 메시지를 이해할 수 있도록 **인터페이스를 통일하는 구현 방법이 바로 상속**인 것이다*

> *다형성을 구현하는 방법은 매우 다양하지만 메시지에 응답하기 위해 실행될 메서드를  
> 컴파일 시점이 아닌 런타임 시점에 결정한다는 공통점이 있다  
> 메시지와 메서드를 **런타임 시점에 바인딩**한다는 것이다*  
>> *런타임 시점에 바인딩 : 지연 바인딩(Lazy Binding) 또는 동적 바인딩(Dynamic Binding)  
> 컴파일 시점에 바인딩 : 초기 바인딩(Early Binding) 또는 정적 바인딩(Static Binding)*
>>> *하나의 메시지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가  
> 지연 바인딩이라는 메커니즘을 사용하기 때문이다*

> *상속을 구현 상속(Implementation Inheritance)과 인터페이스 상속(Interface Inheritance)으로 분류할 수 있다*  
>> *구현 상속 : 서브 클래싱(Subclassing)  
> 인터페이스 상속 : 서브타이핑(Subtyping)*  
>>> *순수하게 **코드를 재사용하기 위한 목적**으로 상속을 사용하는 것을 **구현 상속**이라 부르고  
> 다형적인 협력을 위해 슈퍼 클래스와 서브 클래스가 **인터페이스를 공유**할 수 있도록  
> 상속을 이용하는 것을 **인터페이스 상속**이라고 부른다*  
>>>> *상속은 **구현 상속이 아니라 인터페이스 상속을 위해 사용**해야 한다  
> 구현을 재사용할 목적으로 상속을 사용하면 **변경이 취약한 코드**를 낳게 될 확률이 높다  
> 코드 재사용을 위해서는 상속보다는 **합성(Composition)이 더 좋은 방법**이다  
> 합성은 **다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함**해서 재사용하는 방법을 말한다*

> *상속의 가장 큰 문제점은 캡슐화를 위반한다는 점이다*  
>> *상속을 이용하기 위해서는 슈퍼 클래스의 내부 구조를 잘 알고 있어야 한다  
> 슈퍼 클래스의 구현이 서브 클래스에게 노출되기 때문에 캡슐화가 약화되는 것이다  
> 캡슐화의 약화는 곧 서브 클래스가 슈퍼 클래스에 강하게 결합되도록 만들기 때문에  
> 슈퍼 클래스를 변경할 때 서브 클래스도 함께 변경될 확률을 높인다*