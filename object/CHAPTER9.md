---
sort: 9
---

# 유연한 설계

---

## 개방-폐쇄 원칙

    - Open-Closed Principle, OCP
    - 소프트웨어 개체는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 함

    - 추상화에 의존하는 것
    - 추상화에 의존하기 때문에 컴파일타임 의존성을 수정하지 않고도 런타임 의존성을 쉽게 변경 가능

## 생성 사용 분리

    - 객체에 대한 생성과 사용에 대한 책임은 분리되어야 함

    - 추상화에 의존하기 위해서는 특정 인스턴스를 사용하는 객체 내부에서 구체 클래스의 인스턴스를 생성하면 안됨
        - 필요에 의해 다른 구체 클래스로 대체하려고 할 때 기존 구체 클래스에서 대체할 구체 클래스로 변경이 일어남
        - 기존의 코드를 수정하도록 만들기 때문에 개방-폐쇄 원칙을 위반

    - 객체 생성에 대한 지식은 과도한 결합도를 초래
        - 객체를 생성하기 위해 해당 객체의 타입과 생성자로 전달할 인자 등 과도한 지식을 요구함

    - 객체 생성에 대한 책임은 클라이언트 혹은 생성을 전담하는 팩토리에 부여

### 순수한 가공물

    - Pure Fabrication
    - 도메인 개념만으로는 표현할 수 없는 책임에는 인공적인 객체를 적극 활용할 것
        - 인스턴스 생성을 전담하는 팩토리, 데이터베이스 접근 객체 등

## 의존성 주입

    - Dependency Injection
    - 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
    
### SERVICE LOCATOR 패턴

    - 외부에서 객체에게 의존성을 전달하는 의존성 주입과 달리 객체가 직접 의존성에 해결에 대한 요청을 함
    - 클라이언트에서 SERVICE LOCATOR에게 생성한 인스턴스 전달
    - 인스턴스 필요 시 사용하는 객체에서 SERVICE LOCATOR에게 인스턴스 반환 요청

    - SERVICE LOCATOR 패턴은 의존성을 명시적으로 드러내지 않고 내부에 숨김
        - 명시적으로 드러나지 않기 때문에 해당 의존성에 대한 파악이 곧 코드 내부 구현에 대한 이해로 강요됨 -> 캡슐화 위반

## 의존성 역전 원칙

    - Dependency Inversion Principle, DIP
    - 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안됨
    - 추상화는 구체적인 사항에 의존해서는 안됨

    - 구체 클래스에 의존하는 경우 구체 클래스의 문맥에 강하게 결합될 가능성이 높음
    - 하위로 흐르는 의존성에 의해 하위 수준 객체의 변경이 상위 수준의 객체에 영향을 미침

    - 전통적인 패러다임에서는 상위 수준 모듈이 하위 수준 모듈에 의존
    - 객체지향 패러다임에서는 상위 수준 모듈과 하위 수준 모듈 모두 추상화에 의존

***<span style="color:#f08080">
객체의 생성과 사용에 대한 책임 분리는 곧 OCP와 DIP 위반을 방지한다  
객체를 생성하지 않아도 되어 구체 클래스에 대한 의존이 사라지고(DIP 위반 방지)  
생성된 인스턴스를 인터페이스 타입으로 주입 받기 때문에 런타임 시점에  
사용할 인스턴스를 바인딩하는 것이 가능하다(OCP 위반 방지)
</span>***

        

